# Dynamic Programming

**Workflows**
1. Base case
2. Status and Status changing
3. Choice
4. dp function or dp array

**Key Points**
> Generated by ChatGPT
> Dynamic Programming (DP) is a powerful technique used in algorithm design to solve certain types of problems more efficiently. The key points of DP problems, which differentiate them from other problem-solving approaches, include:
> 1. **Overlapping Subproblems**:
>    - DP is applicable when the problem can be broken down into smaller, overlapping subproblems. Instead of recomputing the solution to a subproblem each time it is encountered, the solution is computed once, stored, and reused whenever needed. This is a critical aspect that differentiates DP from divide-and-conquer algorithms, which work on non-overlapping subproblems.
> 2. **Optimal Substructure**:
>    - Problems suitable for DP have an optimal substructure, meaning that the optimal solution to the problem can be constructed efficiently from the optimal solutions of its subproblems. This property allows building up the solution to the entire problem from the solutions to its subproblems.
> 3. **Memoization or Tabulation**:
>    - **Memoization**: This is a top-down approach where the algorithm solves the problem by solving the top-level problem first and then breaking it down into subproblems. The solutions to these subproblems are stored (typically in a hash table or an array) for future reference.
>    - **Tabulation**: This is a bottom-up approach where the algorithm first solves the smallest subproblems and uses their solutions to build up solutions to larger subproblems. This often involves filling up a DP table in a systematic way.
> 4. **Choice of State**:
>    - The state in DP represents a set of parameters that can uniquely identify a certain position or standing in the given problem. The choice of state is crucial and often involves deep insight into the nature of the problem. The state should capture all necessary information from the past to make future decisions.
> 5. **Formulation of State Transition Equation**:
>    - This involves defining a formula or a method to transition from one state to another. The state transition equation is crucial for the recursive structure of DP and is used in both memoization and tabulation.
> 6. **Initialization**:
>    - Proper initialization of the DP table (or storage structure) is critical, especially for base cases. These base cases are direct solutions to the smallest subproblems and provide the starting point for solving larger problems.
> 7. **Iterative vs. Recursive Implementation**:
>    - DP can be implemented either recursively with memoization or iteratively with tabulation. The choice between these approaches depends on the specific problem, the programming language, and the programmer’s preference.
> 8. **Analyzing Time and Space Complexity**:
>    - An important aspect of DP is understanding its impact on the time and space complexity of the algorithm. DP can significantly reduce the time complexity at the expense of increased space complexity due to the storage of subproblem solutions.
> Understanding these key points is crucial when approaching a problem that might benefit from dynamic programming. Each point plays a significant role in formulating a DP solution that is efficient and effective.

1. 最优子结构
    * If there is 最优子结构
    
2. 状态转移方程
    * (Recurrence or Recursion) 前后项之前关联+base case的描述
    * Examples:
        * Fibonacci Problems: https://labuladong.github.io/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/fib.png
        * Coins Change Problem: https://labuladong.github.io/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/coin.png
        
3. Overlapping sub problems. For example, `Fibonacci Number`
    * Solution:  Cache the middle result
    * Optimization: Space used by Cache

4. Memorization or Tabulation. 
    * LC300. `dp[i]`, the length of longest sub sequence ends with `nums[i]` in `nums`
5. Formulation of State Transition Equation 
    * LC300. `dp[i] = max(dp[i], dp[j])+1), where j = [i-1,i-2,…,0] && nums[j] < nums[i]`

**Problmes**
* LC509. Fibonacci Number
    * Recursive with middle result cached.
    * Recurrence
* LC322. Coins Change 
    * Can be resolve by Recursion or Recurrence
* LC300. Longest Increasing Subsequence
    * dp. O(N^2)
    * binary search <= O(N*logN)
* LC354. Russian Doll Envelopes
    * Iiheat from LC300
    * Sort by width and height with different order
