# Dynamic Programming

**Workflows**
1. Base case
2. Status and Status changing
3. Choice
4. dp function or dp array

**Key Points**
> Generated by ChatGPT
> Dynamic Programming (DP) is a powerful technique used in algorithm design to solve certain types of problems more efficiently. The key points of DP problems, which differentiate them from other problem-solving approaches, include:
> 1. **Overlapping Subproblems**:
>    - DP is applicable when the problem can be broken down into smaller, overlapping subproblems. Instead of recomputing the solution to a subproblem each time it is encountered, the solution is computed once, stored, and reused whenever needed. This is a critical aspect that differentiates DP from divide-and-conquer algorithms, which work on non-overlapping subproblems.
> 2. **Optimal Substructure**:
>    - Problems suitable for DP have an optimal substructure, meaning that the optimal solution to the problem can be constructed efficiently from the optimal solutions of its subproblems. This property allows building up the solution to the entire problem from the solutions to its subproblems.
> 3. **Memoization or Tabulation**:
>    - **Memoization**: This is a top-down approach where the algorithm solves the problem by solving the top-level problem first and then breaking it down into subproblems. The solutions to these subproblems are stored (typically in a hash table or an array) for future reference.
>    - **Tabulation**: This is a bottom-up approach where the algorithm first solves the smallest subproblems and uses their solutions to build up solutions to larger subproblems. This often involves filling up a DP table in a systematic way.
> 4. **Choice of State**:
>    - The state in DP represents a set of parameters that can uniquely identify a certain position or standing in the given problem. The choice of state is crucial and often involves deep insight into the nature of the problem. The state should capture all necessary information from the past to make future decisions.
> 5. **Formulation of State Transition Equation**:
>    - This involves defining a formula or a method to transition from one state to another. The state transition equation is crucial for the recursive structure of DP and is used in both memoization and tabulation.
> 6. **Initialization**:
>    - Proper initialization of the DP table (or storage structure) is critical, especially for base cases. These base cases are direct solutions to the smallest subproblems and provide the starting point for solving larger problems.
> 7. **Iterative vs. Recursive Implementation**:
>    - DP can be implemented either recursively with memoization or iteratively with tabulation. The choice between these approaches depends on the specific problem, the programming language, and the programmer’s preference.
> 8. **Analyzing Time and Space Complexity**:
>    - An important aspect of DP is understanding its impact on the time and space complexity of the algorithm. DP can significantly reduce the time complexity at the expense of increased space complexity due to the storage of subproblem solutions.
> Understanding these key points is crucial when approaching a problem that might benefit from dynamic programming. Each point plays a significant role in formulating a DP solution that is efficient and effective.

1. 最优子结构
    * If there is 最优子结构
    
2. 状态转移方程
    * (Recurrence or Recursion) 前后项之前关联+base case的描述
    * Examples:
        * Fibonacci Problems: https://labuladong.github.io/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/fib.png
        * Coins Change Problem: https://labuladong.github.io/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/coin.png
        
3. Overlapping sub problems. For example, `Fibonacci Number`
    * Solution:  Cache the middle result
    * Optimization: Space used by Cache

4. Memorization or Tabulation. 
    * LC300. `dp[i]`, the length of longest sub sequence ends with `nums[i]` in `nums`
5. Formulation of State Transition Equation 
    * LC300. `dp[i] = max(dp[i], dp[j])+1), where j = [i-1,i-2,…,0] && nums[j] < nums[i]`


**Thinking Patterns**

> 动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。 找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的读者应该能体会。


### DP Analyse Example

Use problem [LC322](https://leetcode.com/problems/coin-change/description/) as an example. 

**最优子结构**

>这个问题是动态规划问题，因为它具有「最优子结构」的.要符合「最优子结构」，子问题间必须互相独立。
>
>回到凑零钱问题，为什么说它符合最优子结构呢？ 假设你有面值为 1, 2, 5 的硬币，你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10, 9, 6 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1, 2, 5 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。


**状态转移方程**

> 那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？
>
>1、确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。
>
>2、确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。
>
>3、明确 dp 函数(Top to Down)/dp数组(Down to Top)的定义。

> Top to Down 
>
> 我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。
>
>所以我们可以这样定义 dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量。

> Down to Top
>
>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，dp 数组的定义和刚才 dp 函数类似，也是把「状态」，也就是目标金额作为变量。不过 dp 函数体现在函数参数，而 dp 数组体现在数组索引：
>
>dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出。


### Problems

| Problems | Possible Solutions | Key Points | Code | Comments |
| :- | :- | :- |:- | :- | 
| [322. Coin Change](https://leetcode.com/problems/coin-change/description/) | DP | | [code](dp_lc322.go) | | 

* LC509. Fibonacci Number
    * Recursive with middle result cached.
    * Recurrence
* LC322. Coins Change 
    * Can be resolve by Recursion or Recurrence
* LC300. Longest Increasing Subsequence
    * dp. O(N^2)
    * binary search <= O(N*logN)
* LC354. Russian Doll Envelopes
    * Iiheat from LC300
    * Sort by width and height with different order

| Types | Problems | Key Points | Possible Solutions | Comments |
| :- | :- | :- |:- | :- | 
| | [2263](https://leetcode.com/problems/make-array-non-decreasing-or-non-increasing/description/) | How to setup the status migration? | [code](backtrack_lc2263.go) | | 


### Sub Sequences Problems


| Problems | Possible Solutions | Key Points | Code | Comments |
| :- | :- | :- |:- | :- | 
| [673. Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/) | 1. DP <br> 2. BIT | 1. DP <br> * How to setup/update dp array for `dpCount`? | [code](dp_lc2263.go) | | 
